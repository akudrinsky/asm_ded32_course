
1. Без конвейера. 
	Этапы обработки: 
		а) Выборка. Все помнят, как устроена команда из предыдущего семестра - сначала идет байт-спецификатор (в современных процессорах все устроено так, что похожие команды имеют схожие номера - icode, ifun). По регистру, обозначающему, откуда из памяти брать следующую команду (x86-64 - rip) считываем ее байт спецификатор и на основе этого можем считать ее аргументы (регистр, адрес памяти и т.п.). Здесь же мы уже можем посчитать адрес следующей команды в памяти. 
		б) Декодирование. На этом этапе из регистрового файла считываются нужные для исполнения команды регистры. (valA, valB)
		в) Выполнение. Арифметико-логическое устройство выполняет операцию, в том числе, возможно, изменяет адрес верхушки стека (valE). Для условных переходов на этом же этапе происходит проверка условия. 
		г) Память. Запись данных в память или считывание из нее. 
		д) Обратная запись результатов в регистровый файл. 
		е) Обновление rip. 

Чтобы понять, как это работает на практике, рассмотрим обработку нескольких комманд (слайд 2-...). valC - аргумент из памяти (например, условные переходы). 

Таким образом, мы создали универсальный процесс обработки любой команды в нашем процессоре. Понятно, что сейчас главная неэффктивность состоит в простаивании большей части ресурсов при обработке команды. Можем ли мы это как-то улучшить?

Давайте подробнее рассмотрим структуру выполнения команды (слайд). Важно заметить, что ни один их этапов обработки команды не нуждается в возвращении на предыдущий этап.






2. Переход к лучшему. 
Заметим, что у нас до сих пор была серьезная неэффективность - мы не могли выполнять следующую команду, не завершив полностью предыдущую - как минимум у нас была проблема с обновлением rip. То есть мы были вынуждены полностью ждать цикл синхронизации, чтобы начать выполнять следующеую каманду. 

Идея конвейера: автомойка. 
Проблема: неравномерность времени исполнения разных этапов. (конвейерные регистры). Пропускная способность конвейера ограничена самым медленным из этапов. 
Проблема: В современных процессорах число этапов обработки команд может достигать 15 штук, и тогда время пересылки данных от одного этапа к другому (тех самых valA, valB, valE) может занимать значительную долю от общего времени цикла обработки команды. 

Предвосхитившись нашей идеей, попробуем реализовать ее в схематичном виде (сначала вид, потом сравнение). Как видно, по сравнению с предыдущей реализацией, сейчас мы хотим сместить этап выбора следующей команды как можно ниже. И это даст нам возможность начинать выполнение следующей команды как можно раньше. 
Заострить внимание: в каждом этапе свои icode. SelectA - слияние сигналов valP (нужен для call на этапе памяти и для условных переходов, если условие не было выполнено. Для всех них нет операнда-регистра) (376). 

Прогнозирование следующего значения rip - 377 страница. 

Еще проблема: 
mov rax, 1
add rbx, rax
mov rax, rbx
Зависимость по данным не дает запустить конвейер. (разумеется, аналогичная проблема встречает нас во всех условных переходах)

	а) нам придется вставлять nop часто. 
	б) Мы можем переложить ответственность за установку этих пустых команд на аппаратный уровень - чтобы процессор, зная историю исполнения команд, как бы включал между командами с зависимостью по данным и командами с зависимостью в управлении (т е условные переходы) так называемые остановы. То есть процессор будет удерживать выполнение определенных этапов конвейера, при этом давая возможность конфликтующей зависимости исчезнуть за счет того что первая часть конфликта успеет пройти. 
Это позволит нам корректно обрабатывать сложные зависимости команд от данных, но по не хотелось бы останавливаться по любому чиху. 
	в) Почему бы не сделать внутри конвейера возможность передачи данных к этапу декодирования от всех этапов, которые следуют после него? (слайд) Тогда мы могли бы иметь актуальные значения регистров без необходимости каждый раз делать останову для обработки вновь поступившей команды. То есть на этапе декодирования соответствующий блок генерирует valA и valB либо собственно из регистрового файла, либо из продвинутых значений. (слайд)

Конечно, даже при такой достаточно умной реализации все равно есть ряд рисков, которые мы не можем эффективно обработать. Одним примером является запись / считывание из памяти, потому что этот этап обработки команды находится в самом конце - остановы делать все равно придется. Пример:
mov rax, [rbx]
add rax, rcx

Таким образом, у нас есть следующие типы проблем, которые мы можем решить только с помощью останова (слайд). 
a) ret. Обработка следующей команды может начаться только после этапа памяти. 
б) Давайте поговорим о втором типе проблем - некорректно спрогнозированные ветвления. Прогнозируем зеленую стрелку. Не прошла. Что тогда? Ничего плохого, команды до этапа выполнения не меняют ничего -> можем просто забить на них. Процессор вставлят вместо них bubble - останову. 







VFMADD132SD
VPADD (q|w|b|d)
VGATHERDPS ymm1, adress, ymm2 (ymm1 <- от адреса, задаваемого следующим операндом, по смещениям, задаваемым dword из ymm2 )
VPXOR ymm1, ymm2, ymm3/m256 (до этого только с xmm). 

Можно ли SSE intrinsics?




